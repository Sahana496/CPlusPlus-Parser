FOLLOW(Z):
$
FOLLOW(Translation_unit):
$
FOLLOW(Declaration_seq):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Declaration):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Block_declaration):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
case
default
{
constant
string_literal
this
::
inc_op
dec_op
&
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
try
else
FOLLOW(Simple_declaration):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
case
default
{
constant
string_literal
this
::
inc_op
dec_op
&
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
try
else
FOLLOW(Declaration_specifiers):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
FOLLOW(Declaration_specifiers_seq):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
FOLLOW(Storage_class_specifier):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
FOLLOW(Function_specifier):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
FOLLOW(Typedef_name):
FOLLOW(Class_name):
{
,
::
FOLLOW(Type_specifier):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
]
?
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Type_name):
FOLLOW(Namespace_name):
;
::
FOLLOW(Original_namespace_name):
;
::
{
FOLLOW(Namespace_alias):
;
::
FOLLOW(Namespace_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Named_namespace_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Original_namespace_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Extension_namespace_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Unnamed_namespace_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
FOLLOW(Namespace-body):
}
FOLLOW(Using_directive):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
case
default
{
constant
string_literal
this
::
inc_op
dec_op
&
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
try
else
FOLLOW(Init_declarator_list):
;
,
FOLLOW(Init_declarator):
;
,
FOLLOW(Declarator):
;
,
=
)
{
try
FOLLOW(Direct_declarator):
;
,
=
)
{
try
[
(
FOLLOW(Pointer):
identifier
(
)
,
=
[
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
;
]
:
?
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Cv_qualifier_list):
throw
;
,
=
)
{
try
[
(
*
identifier
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
]
:
?
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
const
volatile
FOLLOW(Cv_qualifier):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
]
?
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
throw
{
try
FOLLOW(Type_id):
)
,
FOLLOW(Type_specifier_seq):
)
,
*
(
[
identifier
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Abstract_declarator):
)
,
=
FOLLOW(Direct_abstract_declarator):
)
,
=
[
(
FOLLOW(Parameter_declaration_clause):
)
FOLLOW(Parameter_declaration_list):
)
,
FOLLOW(Parameter_declaration):
)
,
FOLLOW(Function_definition):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
:
private
public
protected
FOLLOW(Initializer):
;
,
}
FOLLOW(Initializer_list):
}
,
FOLLOW(Class_specifier):
;
*
identifier
(
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
[
)
,
=
:
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
]
?
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Class_head):
{
FOLLOW(Class_key):
identifier
:
FOLLOW(Member_specification):
}
FOLLOW(Member_declaration):
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
:
;
private
public
protected
}
FOLLOW(Member_declarator_list):
;
,
FOLLOW(Member_declarator):
;
,
FOLLOW(Base_clause):
{
FOLLOW(Base_specifier_list):
{
,
FOLLOW(Base_specifier):
{
,
FOLLOW(Access_specifier):
:
::
identifier
virtual
FOLLOW(Identifier_list):
)
,
FOLLOW(Statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Labeled_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Compound_statement):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
:
private
public
protected
case
default
{
constant
string_literal
this
::
inc_op
dec_op
&
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
try
else
catch
FOLLOW(Declaration_list):
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
FOLLOW(Statement_list):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
FOLLOW(Expression_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
)
FOLLOW(Selection_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Iteration_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Jump_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Declaration_statement):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Try_block):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
FOLLOW(Function_try_block):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
}
:
private
public
protected
FOLLOW(Handler_seq):
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
$
namespace
:
private
public
protected
FOLLOW(Handler):
catch
}
identifier
case
default
{
;
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
if
switch
while
do
for
goto
continue
break
return
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
using
try
else
$
namespace
:
private
public
protected
FOLLOW(Exception_declaration):
)
FOLLOW(Throw_expression):
)
,
;
]
:
FOLLOW(Exception_specification):
;
,
=
)
{
try
[
(
FOLLOW(Type_id_list):
)
,
FOLLOW(Primary_expression):
[
(
.
ptr_op
inc_op
dec_op
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Nested_name_specifier):
identifier
FOLLOW(Class-or-namespace-name):
::
FOLLOW(Postfix_expression):
[
(
.
ptr_op
inc_op
dec_op
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Argument_expression_list):
)
,
FOLLOW(Unary_expression):
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Unary_operator):
identifier
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
FOLLOW(New_expression):
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(New_placement):
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
FOLLOW(New_type_id):
(
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(New_declarator):
(
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Direct_new_declarator):
(
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
[
FOLLOW(New_initializer):
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Delete_expression):
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Cast_expression):
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
=
mul_assign
div_assign
mod_assign
add_assign
sub_assign
left_assign
right_assign
and_assign
or_assign
xor_assign
FOLLOW(Multiplicative_expression):
*
/
%
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Additive_expression):
+
-
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Shift_expression):
left_op
right_op
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Relational_expression):
<
>
le_op
ge_op
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Equality_expression):
eq_op
ne_op
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(And_expression):
&
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Exclusive_or_expression):
^
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Inclusive_or_expression):
|
and_op
or_op
)
,
;
]
:
?
FOLLOW(Logical_and_expression):
and_op
or_op
)
,
;
]
:
?
FOLLOW(Logical_or_expression):
or_op
)
,
;
]
:
?
FOLLOW(Conditional_expression):
)
,
;
]
:
FOLLOW(Assignment_expression):
)
,
;
]
:
FOLLOW(Assignment_operator):
identifier
constant
string_literal
(
this
::
inc_op
dec_op
&
*
+
-
~
!
sizeof
new
delete
throw
FOLLOW(Expression):
;
)
]
:
,
FOLLOW(Constant_expression):
]
;
,
:
FOLLOW(Preprocessing_token):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
<
"
constant
.
string_literal
FOLLOW(Header_name):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
<
"
constant
.
string_literal
FOLLOW(Pp-number):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
<
"
constant
.
string_literal
FOLLOW(Preprocessing_file):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
FOLLOW(Preprocessing):
FOLLOW(Group):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
FOLLOW(Group_part):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
FOLLOW(Control_line):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
FOLLOW(Replacement_list):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
FOLLOW(Pp_tokens):
$
extern
static
auto
register
inline
virtual
explicit
void
char
short
int
long
float
double
signed
bool
unsigned
type_name
class
struct
union
const
volatile
friend
typedef
*
identifier
(
;
using
namespace
#
<
"
constant
.
string_literal
